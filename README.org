#+title: mercury-ad: Mercury library for automatic differentiation
#+author: Mark Clements

* Introduction

A simple Mercury library for automatic differentiation that includes forward and backward differentiation. At present, the library is a proof of concept and needs to be extended to include many other functions. 

This adapts the approach presented in https://github.com/qobi/AD-Rosetta-Stone/. Interestingly, most of the functional approaches for backward differentiation described in https://github.com/qobi/AD-Rosetta-Stone/ uses references to update a tape in-place, whereas this library implements a more pure functional approach for the fanout and reverse phases. [For the technical details, I added an integer tag to each tape and then collected the sensitivity values using a map for extracting the gradients.]

* Test examples

The test code is here:

#+begin_src bash :results output :exports results
  cat test_ad.m
#+end_src

#+RESULTS:
#+begin_example
:- module test_ad.

:- interface.
:- import_module io.
:- pred main(io::di, io::uo) is det.

:- implementation.
:- use_module math.
:- import_module ad.
:- import_module ad.v.
:- import_module list.
:- import_module float.

main(!IO) :-
    derivative_F(func(X) = exp(base(2.0)*X), base(1.0), GradF),
    print_line("Expected: ", !IO), print_line(base(math.exp(2.0)*2.0), !IO),
    print_line(GradF, !IO),
    gradient_R(func(List) = Y :-
		   (if List=[A,B] then Y=exp(base(2.0)*A)+B else Y = base(0.0)),
		   from_list([1.0,3.0]), Grad0),
    print_line("Expected: ", !IO), print_line([base(math.exp(2.0)*2.0),base(1.0)], !IO),
    print_line(Grad0, !IO),
    gradient_R(func(List) = Y :-
		   (if List=[A,B] then Y=B+A*A*A else Y = base(0.0)),
		   [base(1.1),base(2.3)], Grad),
    print_line("Expected: ", !IO), print_line([base(3.0*1.1*1.1),base(1.0)], !IO),
    print_line(Grad, !IO),
    gradient_R(func(List) = Y :-
		   (if List=[A,B] then Y=exp(B+A*A*A) else Y = base(0.0)),
		   [base(1.1),base(2.3)], Grad2),
    print_line("Expected: ", !IO),
    print_line([base(math.exp(2.3+1.1*1.1*1.1)*(3.0*1.1*1.1)),
		base(math.exp(2.3+1.1*1.1*1.1))], !IO),
    print_line(Grad2, !IO),
    gradient_F(func(List) = Y :-
		   (if List=[A,B] then Y=exp(B+A*A*A) else Y = base(0.0)),
		   [base(1.1),base(2.3)], Grad3),
    print_line("Expected: ", !IO),
    print_line([base(math.exp(2.3+1.1*1.1*1.1)*(3.0*1.1*1.1)),
		base(math.exp(2.3+1.1*1.1*1.1))], !IO),
    print_line(Grad3, !IO),
    multivariate_argmin_F(func(AB) = Y :-
			      if AB = [A,B]
				      then Y = A*A+(B-base(1.0))*(B-base(1.0))
								  else Y=base(0.0),
			  [base(1.0),base(2.0)],Y4),
    print_line("Expected: ", !IO),
    print_line([base(0.0),base(1.0)], !IO),
    print_line(Y4,!IO),
    multivariate_argmin_R(func(AB) = Y :-
			      if AB = [A,B]
				      then Y = A*A+(B-base(1.0))*(B-base(1.0))
								  else Y=base(0.0),
			  [base(1.0),base(2.0)],Y5),
    print_line("Expected: ", !IO),
    print_line([base(0.0),base(1.0)], !IO),
    print_line(Y5,!IO),
    multivariate_argmin_R(rosenbrock,
			  [base(-3.0),base(4.0)],Y6),
    print_line("Expected: ", !IO),
    print_line([base(1.0),base(1.0)], !IO),
    print_line(Y6,!IO).

:- func rosenbrock(v_ad_number) = ad_number.
rosenbrock(In) = Result :-
    In = [X,Y] ->
    A = base(1.0),
    B = base(100.0),
    Result = (A-X)*(A-X)+B*(Y-X*X)*(Y-X*X)
    ;
    Result = base(0.0).
#+end_example

Running the code and getting output:

#+begin_src bash :results output :exports both
  mmc --make test_ad libad && ./test_ad
#+end_src

#+RESULTS:
#+begin_example
Expected: 
base(14.7781121978613)
base(14.7781121978613)
Expected: 
[base(14.7781121978613), base(1.0)]
[base(14.7781121978613), base(1.0)]
Expected: 
[base(3.630000000000001), base(1.0)]
[base(3.630000000000001), base(1.0)]
Expected: 
[base(137.0344903162743), base(37.75054829649429)]
[base(137.0344903162743), base(37.75054829649429)]
Expected: 
[base(137.0344903162743), base(37.75054829649429)]
[base(137.0344903162743), base(37.75054829649429)]
Expected: 
[base(0.0), base(1.0)]
[base(-4.2936212903462384e-09), base(0.9999999957063787)]
Expected: 
[base(0.0), base(1.0)]
[base(-4.2936212903462384e-09), base(0.9999999957063787)]
Expected: 
[base(1.0), base(1.0)]
[base(0.9999914554400818), base(0.9999828755368568)]
#+end_example
